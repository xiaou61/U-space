# 线程池与并发工具类使用指南

本项目提供了两个核心并发工具类，用于简化多线程编程和并发控制。

## 目录

- [ThreadPoolUtils - 线程池工具类](#threadpoolutils---线程池工具类)
- [ConcurrentUtils - 并发控制工具类](#concurrentutils---并发控制工具类)

---

## ThreadPoolUtils - 线程池工具类

**包路径**: `com.xiaou.common.utils.ThreadPoolUtils`

提供线程池管理、异步任务执行、批量并行处理、超时控制、重试机制等功能。

### 1. 获取线程池

```java
// 通用线程池（适合一般任务）
ExecutorService common = ThreadPoolUtils.getCommonExecutor();

// IO密集型线程池（适合网络请求、文件读写等IO操作）
ExecutorService io = ThreadPoolUtils.getIoExecutor();

// CPU密集型线程池（适合计算任务）
ExecutorService cpu = ThreadPoolUtils.getCpuExecutor();

// 虚拟线程执行器（Java 21+，不支持时自动回退到IO线程池）
ExecutorService virtual = ThreadPoolUtils.getVirtualExecutor();

// 调度线程池（定时任务）
ScheduledExecutorService scheduler = ThreadPoolUtils.getScheduler();

// 创建自定义线程池
ExecutorService custom = ThreadPoolUtils.getOrCreatePool("myPool", 5, 10, 100);
```

### 2. 异步任务执行

```java
// 无返回值的异步任务
ThreadPoolUtils.runAsync(() -> {
    // 执行任务
    sendEmail();
});

// 有返回值的异步任务
CompletableFuture<User> future = ThreadPoolUtils.supplyAsync(() -> {
    return userService.getById(userId);
});

// 使用IO线程池执行
CompletableFuture<String> result = ThreadPoolUtils.supplyAsyncIO(() -> {
    return httpClient.get(url);
});

// 使用CPU线程池执行
CompletableFuture<Integer> calc = ThreadPoolUtils.supplyAsyncCPU(() -> {
    return heavyCalculation();
});

// 使用虚拟线程执行（适合大量IO任务）
CompletableFuture<Data> data = ThreadPoolUtils.supplyAsyncVirtual(() -> {
    return fetchFromRemote();
});
```

### 3. 批量并行处理

```java
// 并行处理集合
List<Long> userIds = Arrays.asList(1L, 2L, 3L, 4L, 5L);

// 基础并行处理
List<User> users = ThreadPoolUtils.parallelMap(userIds, id -> userService.getById(id));

// 使用IO线程池并行处理（推荐用于网络请求）
List<String> responses = ThreadPoolUtils.parallelMapIO(urls, url -> httpClient.get(url));

// 使用虚拟线程并行处理（适合大量IO任务）
List<Data> dataList = ThreadPoolUtils.parallelMapVirtual(ids, id -> fetchData(id));

// 带超时的并行处理（超时返回null）
List<Result> results = ThreadPoolUtils.parallelMapWithTimeout(
    items, 
    item -> processItem(item),
    30, TimeUnit.SECONDS
);

// 限制并发数的并行处理（避免压垮下游）
List<Response> responses = ThreadPoolUtils.parallelMapWithLimit(
    requests,
    req -> callApi(req),
    5  // 最大并发数
);

// 快速失败模式（任一任务失败立即终止所有任务）
try {
    List<Result> results = ThreadPoolUtils.parallelMapFailFast(items, this::process);
} catch (RuntimeException e) {
    // 处理失败
}
```

### 4. 超时控制

```java
// 带超时的异步执行
CompletableFuture<Data> future = ThreadPoolUtils.supplyAsyncWithTimeout(
    () -> slowOperation(),
    10, TimeUnit.SECONDS
);

// 带超时和默认值的异步执行
CompletableFuture<String> future = ThreadPoolUtils.supplyAsyncWithDefault(
    () -> fetchData(),
    5, TimeUnit.SECONDS,
    "默认值"  // 超时返回此值
);

// 同步执行带超时
try {
    Result result = ThreadPoolUtils.executeWithTimeout(
        () -> longRunningTask(),
        30, TimeUnit.SECONDS
    );
} catch (RuntimeException e) {
    // 处理超时
}
```

### 5. 重试机制

```java
// 基础重试（默认3次，间隔1秒）
String result = ThreadPoolUtils.executeWithRetry(() -> {
    return unstableApi.call();
});

// 自定义重试次数和间隔
String result = ThreadPoolUtils.executeWithRetry(
    () -> unstableApi.call(),
    5,      // 重试5次
    2000    // 间隔2秒
);

// 指数退避重试（推荐用于网络请求）
// 重试间隔: 500ms -> 1000ms -> 2000ms -> 4000ms...
String result = ThreadPoolUtils.executeWithExponentialBackoff(
    () -> httpClient.post(url, data),
    3,      // 重试3次
    500,    // 初始间隔500ms
    10000   // 最大间隔10秒
);

// 条件重试（只有特定异常才重试）
String result = ThreadPoolUtils.executeWithConditionalRetry(
    () -> callService(),
    3,
    1000,
    ex -> ex instanceof TimeoutException  // 只有超时异常才重试
);

// 异步重试
CompletableFuture<Data> future = ThreadPoolUtils.supplyAsyncWithRetry(
    () -> fetchData(),
    3, 1000
);
```

### 6. 定时调度

```java
// 延迟执行
ThreadPoolUtils.schedule(() -> {
    sendReminder();
}, 5, TimeUnit.MINUTES);

// 固定频率执行（每5秒执行一次）
ScheduledFuture<?> task = ThreadPoolUtils.scheduleAtFixedRate(
    () -> collectMetrics(),
    0,      // 初始延迟
    5,      // 间隔
    TimeUnit.SECONDS
);

// 固定延迟执行（上次执行完成后5秒再执行）
ScheduledFuture<?> task = ThreadPoolUtils.scheduleWithFixedDelay(
    () -> syncData(),
    0,
    5,
    TimeUnit.SECONDS
);

// 取消定时任务
task.cancel(false);
```

### 7. 链式异步操作

```java
// 链式调用
User user = ThreadPoolUtils.asyncChain(() -> userService.getById(userId))
    .thenApply(u -> {
        u.setLastLoginTime(new Date());
        return u;
    })
    .thenAccept(u -> log.info("用户登录: {}", u.getName()))
    .onError(ex -> {
        log.error("获取用户失败", ex);
        return new User();  // 返回默认值
    })
    .timeout(10, TimeUnit.SECONDS)
    .get();

// 获取Future
CompletableFuture<Data> future = ThreadPoolUtils.asyncChain(() -> fetchData())
    .thenApply(this::transform)
    .toFuture();
```

### 8. 线程池监控与管理

```java
// 获取线程池状态
Map<String, Object> stats = ThreadPoolUtils.getCommonPoolStats();
// 返回: {corePoolSize, maximumPoolSize, activeCount, poolSize, queueSize, ...}

// 获取所有线程池状态
Map<String, Map<String, Object>> allStats = ThreadPoolUtils.getAllPoolStats();

// 动态调整线程池参数
ThreadPoolUtils.setCorePoolSize(ThreadPoolUtils.getCommonExecutor(), 10);
ThreadPoolUtils.setMaxPoolSize(ThreadPoolUtils.getCommonExecutor(), 20);

// 预热线程池（提前创建核心线程）
ThreadPoolUtils.prestartAllPools();

// 使用配置类创建线程池
ThreadPoolExecutor executor = ThreadPoolUtils.PoolConfig.builder()
    .coreSize(5)
    .maxSize(20)
    .queueSize(500)
    .threadNamePrefix("my-task")
    .keepAliveSeconds(120)
    .build();
```

---

## ConcurrentUtils - 并发控制工具类

**包路径**: `com.xiaou.common.utils.ConcurrentUtils`

提供限流器、熔断器、锁工具、计数器、同步屏障等并发控制原语。

### 1. 限流器

#### 令牌桶限流器

```java
// 获取或创建限流器（每秒100个请求）
RateLimiter limiter = ConcurrentUtils.getRateLimiter("api", 100);

// 阻塞获取许可
limiter.acquire();
callApi();

// 非阻塞尝试获取许可
if (limiter.tryAcquire()) {
    callApi();
} else {
    // 被限流，返回错误
    throw new RateLimitException("请求过于频繁");
}

// 带超时的获取许可
if (limiter.tryAcquire(1, 100, TimeUnit.MILLISECONDS)) {
    callApi();
}

// 带限流执行任务
String result = limiter.executeWithLimit(() -> callApi());

// 非阻塞执行，失败返回null
String result = limiter.tryExecuteWithLimit(() -> callApi());
```

#### 滑动窗口限流器

```java
// 创建滑动窗口限流器：1秒内最多100个请求，分10个窗口
SlidingWindowRateLimiter limiter = new ConcurrentUtils.SlidingWindowRateLimiter(
    100,    // 最大请求数
    1000,   // 窗口时长（毫秒）
    10      // 窗口分片数
);

if (limiter.tryAcquire()) {
    processRequest();
}

// 获取当前窗口内的请求数
long currentCount = limiter.getCurrentCount();
```

### 2. 熔断器

```java
// 获取或创建熔断器（5次失败后熔断，30秒后尝试恢复）
CircuitBreaker breaker = ConcurrentUtils.getCircuitBreaker("userService", 5, 30000);

// 执行带熔断保护的任务
try {
    User user = breaker.execute(() -> userService.getById(userId));
} catch (CircuitBreakerOpenException e) {
    // 熔断器已打开，拒绝请求
    log.warn("服务熔断中");
}

// 带降级的执行
User user = breaker.executeWithFallback(
    () -> userService.getById(userId),      // 主逻辑
    () -> getCachedUser(userId)             // 降级逻辑
);

// 检查熔断器状态
CircuitBreaker.State state = breaker.getState();
// CLOSED - 正常
// OPEN - 熔断中
// HALF_OPEN - 半开状态（尝试恢复）

// 获取失败次数
int failures = breaker.getFailureCount();

// 手动重置熔断器
breaker.reset();
```

### 3. 锁工具

#### 安全锁操作

```java
Lock lock = new ReentrantLock();

// 安全执行锁内操作（自动释放锁）
String result = ConcurrentUtils.withLock(lock, () -> {
    return doSomething();
});

// 无返回值版本
ConcurrentUtils.withLock(lock, () -> {
    updateData();
});

// 带超时的锁操作
String result = ConcurrentUtils.tryWithLock(lock, 5, TimeUnit.SECONDS, () -> {
    return doSomething();
});
// 获取锁失败返回null
```

#### 读写锁

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();

// 读锁操作
Data data = ConcurrentUtils.withReadLock(rwLock, () -> {
    return cache.get(key);
});

// 写锁操作
ConcurrentUtils.withWriteLock(rwLock, () -> {
    cache.put(key, value);
    return null;
});
```

#### 分段锁（减少锁竞争）

```java
// 获取或创建分段锁（16个分段）
StripedLock stripedLock = ConcurrentUtils.getStripedLock("userLock", 16);

// 根据key获取对应的锁段
Long userId = 12345L;
User user = stripedLock.withLock(userId, () -> {
    // 只有相同userId会竞争同一把锁
    return updateUser(userId);
});

// 也可以手动获取锁
Lock lock = stripedLock.getLock(userId);
lock.lock();
try {
    updateUser(userId);
} finally {
    lock.unlock();
}
```

### 4. 并发计数器

#### 高性能计数器

```java
// 创建计数器
ConcurrentUtils.Counter counter = new ConcurrentUtils.Counter();

// 操作
counter.increment();        // +1
counter.decrement();        // -1
counter.add(10);           // +10

// 获取值
long count = counter.get();

// 获取并重置
long count = counter.getAndReset();
```

#### 统计器

```java
// 创建统计器
ConcurrentUtils.Statistics stats = new ConcurrentUtils.Statistics();

// 记录值（如响应时间）
stats.record(150);  // 150ms
stats.record(200);
stats.record(100);

// 获取统计信息
long count = stats.getCount();      // 3
long sum = stats.getSum();          // 450
long min = stats.getMin();          // 100
long max = stats.getMax();          // 200
double avg = stats.getAverage();    // 150.0

// 打印统计
System.out.println(stats);
// Statistics{count=3, sum=450, min=100, max=200, avg=150.00}

// 重置
stats.reset();
```

### 5. 同步屏障

#### CountDownLatch

```java
// 创建倒计时器
CountDownLatch latch = ConcurrentUtils.createLatch(3);

// 在多个线程中
executor.submit(() -> {
    doTask1();
    latch.countDown();
});
executor.submit(() -> {
    doTask2();
    latch.countDown();
});
executor.submit(() -> {
    doTask3();
    latch.countDown();
});

// 等待所有任务完成
ConcurrentUtils.awaitLatch(latch);
// 或带超时
boolean completed = ConcurrentUtils.awaitLatch(latch, 30, TimeUnit.SECONDS);
```

#### CyclicBarrier

```java
// 创建循环屏障（3个参与者）
CyclicBarrier barrier = ConcurrentUtils.createBarrier(3, () -> {
    // 所有线程到达后执行
    System.out.println("所有线程准备就绪！");
});

// 在多个线程中
executor.submit(() -> {
    prepare();
    ConcurrentUtils.awaitBarrier(barrier);  // 等待其他线程
    execute();
});
```

### 6. 信号量

```java
// 创建信号量（最多5个并发）
Semaphore semaphore = ConcurrentUtils.createSemaphore(5);

// 使用信号量执行任务
String result = ConcurrentUtils.withSemaphore(semaphore, () -> {
    return callLimitedResource();
});

// 带超时和默认值
String result = ConcurrentUtils.tryWithSemaphore(
    semaphore,
    1, TimeUnit.SECONDS,
    () -> callLimitedResource(),
    "默认值"
);
```

### 7. 延迟初始化

#### 懒加载

```java
// 创建懒加载容器
Lazy<ExpensiveObject> lazy = ConcurrentUtils.lazy(() -> {
    return new ExpensiveObject();  // 只在首次调用时创建
});

// 获取值（线程安全）
ExpensiveObject obj = lazy.get();

// 检查是否已初始化
boolean initialized = lazy.isInitialized();

// 重置（下次get会重新创建）
lazy.reset();
```

#### 带过期时间的缓存值

```java
// 创建带TTL的缓存值（5分钟过期）
ExpiringValue<Config> configCache = ConcurrentUtils.expiringValue(
    () -> loadConfigFromDb(),
    Duration.ofMinutes(5)
);

// 获取值（过期自动刷新）
Config config = configCache.get();

// 检查是否过期
boolean expired = configCache.isExpired();

// 强制失效
configCache.invalidate();
```

### 8. 单次执行

```java
// 创建单次执行容器
Once once = ConcurrentUtils.once();

// 多线程调用，只有第一个执行
// 其他线程会等待首次执行完成
executor.submit(() -> once.run(() -> initializeOnce()));
executor.submit(() -> once.run(() -> initializeOnce()));
executor.submit(() -> once.run(() -> initializeOnce()));

// 检查是否已执行
boolean executed = once.isExecuted();
```

### 9. 工具方法

```java
// 安全休眠（不抛InterruptedException）
ConcurrentUtils.sleep(1000);
ConcurrentUtils.sleep(Duration.ofSeconds(5));

// 自旋等待条件满足
boolean success = ConcurrentUtils.spinWait(
    () -> isReady(),  // 条件
    5000              // 超时毫秒
);

// 获取/设置当前线程名
String name = ConcurrentUtils.currentThreadName();
ConcurrentUtils.setThreadName("worker-1");
```

---

## 最佳实践

### 1. 选择合适的线程池

```java
// IO密集型任务（网络请求、数据库访问、文件读写）
ThreadPoolUtils.supplyAsyncIO(() -> httpClient.get(url));
ThreadPoolUtils.parallelMapIO(urls, this::fetch);

// CPU密集型任务（计算、加密、压缩）
ThreadPoolUtils.supplyAsyncCPU(() -> encrypt(data));

// 大量轻量IO任务（Java 21+推荐使用虚拟线程）
ThreadPoolUtils.parallelMapVirtual(ids, this::fetchSmallData);
```

### 2. 合理使用限流和熔断

```java
// 对外部API调用添加限流和熔断
public String callExternalApi(String param) {
    RateLimiter limiter = ConcurrentUtils.getRateLimiter("externalApi", 50);
    CircuitBreaker breaker = ConcurrentUtils.getCircuitBreaker("externalApi", 5, 30000);
    
    return limiter.executeWithLimit(() -> 
        breaker.executeWithFallback(
            () -> externalClient.call(param),
            () -> getCachedResult(param)
        )
    );
}
```

### 3. 使用指数退避重试

```java
// 网络请求推荐使用指数退避，避免雪崩
String result = ThreadPoolUtils.executeWithExponentialBackoff(
    () -> httpClient.post(url, data),
    3, 500, 10000
);
```

### 4. 批量处理时控制并发数

```java
// 避免压垮下游服务
List<Response> responses = ThreadPoolUtils.parallelMapWithLimit(
    requests, 
    this::callDownstream, 
    10  // 最多10个并发
);
```

---

## 类图

```
ThreadPoolUtils
├── 线程池管理
│   ├── getCommonExecutor()
│   ├── getIoExecutor()
│   ├── getCpuExecutor()
│   ├── getVirtualExecutor()
│   └── getOrCreatePool()
├── 异步执行
│   ├── runAsync()
│   ├── supplyAsync()
│   └── supplyAsyncXxx()
├── 批量并行
│   ├── parallelMap()
│   ├── parallelMapIO()
│   ├── parallelMapVirtual()
│   ├── parallelMapWithTimeout()
│   ├── parallelMapWithLimit()
│   └── parallelMapFailFast()
├── 重试机制
│   ├── executeWithRetry()
│   ├── executeWithExponentialBackoff()
│   └── executeWithConditionalRetry()
├── 定时调度
│   ├── schedule()
│   ├── scheduleAtFixedRate()
│   └── scheduleWithFixedDelay()
└── 链式操作
    └── asyncChain()

ConcurrentUtils
├── 限流器
│   ├── RateLimiter (令牌桶)
│   └── SlidingWindowRateLimiter (滑动窗口)
├── 熔断器
│   └── CircuitBreaker
├── 锁工具
│   ├── withLock()
│   ├── withReadLock()
│   ├── withWriteLock()
│   └── StripedLock (分段锁)
├── 计数器
│   ├── Counter
│   └── Statistics
├── 同步屏障
│   ├── createLatch()
│   └── createBarrier()
├── 信号量
│   └── withSemaphore()
└── 延迟初始化
    ├── Lazy
    ├── ExpiringValue
    └── Once
```
