# 消息通知模块技术方案 v1.0.0

## 1. 方案概述

### 1.1 设计目标
- **简单易用**：提供一个通用工具类，调用方式简单直观
- **轻量化**：最小化依赖，减少复杂度
- **高性能**：支持异步发送，不阻塞主流程
- **易扩展**：预留扩展接口，支持后续功能增强

### 1.2 核心设计思路
- 在 `xiaou-common` 中提供统一的 `NotificationUtil` 工具类
- 工具类封装所有消息发送逻辑，对外提供简洁API
- 数据库设计精简，只保留核心表结构
- 支持同步/异步两种发送方式

## 2. 核心工具类设计

### 2.1 NotificationUtil 工具类

```java
package com.xiaou.common.utils;

import org.springframework.stereotype.Component;

/**
 * 消息通知工具类
 * 使用方式：NotificationUtil.sendXxx()
 */
@Component
public class NotificationUtil {
    
    /**
     * 发送系统公告（全站广播）
     * @param title 公告标题
     * @param content 公告内容
     * @param priority 优先级：HIGH/MEDIUM/LOW
     */
    public static void sendAnnouncement(String title, String content, String priority) {
        // 实现逻辑
    }
    
    /**
     * 发送个人消息
     * @param receiverId 接收者ID
     * @param title 消息标题
     * @param content 消息内容
     */
    public static void sendPersonalMessage(Long receiverId, String title, String content) {
        // 实现逻辑
    }
    
    /**
     * 发送个人消息（带类型）
     * @param receiverId 接收者ID
     * @param title 消息标题
     * @param content 消息内容
     * @param type 消息类型
     */
    public static void sendPersonalMessage(Long receiverId, String title, String content, String type) {
        // 实现逻辑
    }
    
    /**
     * 批量发送消息
     * @param receiverIds 接收者ID列表
     * @param title 消息标题
     * @param content 消息内容
     */
    public static void sendBatchMessage(List<Long> receiverIds, String title, String content) {
        // 实现逻辑
    }
    
    /**
     * 发送模板消息
     * @param receiverId 接收者ID
     * @param templateCode 模板代码
     * @param params 模板参数
     */
    public static void sendTemplateMessage(Long receiverId, String templateCode, Map<String, Object> params) {
        // 实现逻辑
    }
    
    /**
     * 异步发送消息（推荐使用）
     * @param receiverId 接收者ID
     * @param title 消息标题
     * @param content 消息内容
     */
    public static void sendMessageAsync(Long receiverId, String title, String content) {
        // 异步实现逻辑
    }
    
    /**
     * 获取用户未读消息数量
     * @param userId 用户ID
     * @return 未读消息数量
     */
    public static int getUnreadCount(Long userId) {
        // 实现逻辑
        return 0;
    }
}
```

### 2.2 使用示例

```java
// 发送系统公告
NotificationUtil.sendAnnouncement("系统维护通知", "系统将于今晚进行维护", "HIGH");

// 发送个人消息
NotificationUtil.sendPersonalMessage(1001L, "欢迎消息", "欢迎加入我们的平台！");

// 发送社区互动消息
NotificationUtil.sendPersonalMessage(1001L, "帖子被点赞", "您的帖子《Spring Boot实践》收到了新的点赞", "COMMUNITY_INTERACTION");

// 异步发送（推荐）
NotificationUtil.sendMessageAsync(1001L, "学习提醒", "您有新的面试题待练习");

// 批量发送
List<Long> userIds = Arrays.asList(1001L, 1002L, 1003L);
NotificationUtil.sendBatchMessage(userIds, "活动通知", "新年活动即将开始！");

// 获取未读数量
int unreadCount = NotificationUtil.getUnreadCount(1001L);
```

## 3. 数据库设计

### 3.1 消息主表（notification）

```sql
CREATE TABLE notification (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '消息ID',
    title VARCHAR(200) NOT NULL COMMENT '消息标题',
    content TEXT COMMENT '消息内容',
    type VARCHAR(50) DEFAULT 'PERSONAL' COMMENT '消息类型',
    priority VARCHAR(20) DEFAULT 'LOW' COMMENT '优先级：HIGH/MEDIUM/LOW',
    sender_id BIGINT COMMENT '发送者ID（系统消息为0）',
    receiver_id BIGINT COMMENT '接收者ID（为NULL表示全站公告）',
    status VARCHAR(20) DEFAULT 'UNREAD' COMMENT '状态：UNREAD/READ/DELETED',
    read_time DATETIME COMMENT '阅读时间',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    INDEX idx_receiver_status (receiver_id, status),
    INDEX idx_created_time (created_time),
    INDEX idx_type (type)
) COMMENT='消息通知表';
```

### 3.2 消息模板表（notification_template）（可选）

```sql
CREATE TABLE notification_template (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '模板ID',
    code VARCHAR(50) NOT NULL COMMENT '模板代码',
    name VARCHAR(100) NOT NULL COMMENT '模板名称',
    title_template VARCHAR(200) NOT NULL COMMENT '标题模板',
    content_template TEXT NOT NULL COMMENT '内容模板',
    is_enabled TINYINT DEFAULT 1 COMMENT '是否启用',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    UNIQUE KEY uk_code (code)
) COMMENT='消息模板表';
```

## 4. 技术实现细节

### 4.1 目录结构

```
xiaou-common/
└── src/main/java/com/xiaou/common/
    ├── utils/
    │   └── NotificationUtil.java           # 核心工具类
    ├── domain/
    │   └── Notification.java               # 消息实体
    ├── mapper/
    │   └── NotificationMapper.java         # MyBatis Mapper
    └── service/
        └── NotificationService.java        # 内部服务类
```

### 4.2 核心实体类

```java
package com.xiaou.common.domain;

import com.fasterxml.jackson.annotation.JsonFormat;
import java.time.LocalDateTime;

/**
 * 消息通知实体
 */
public class Notification {
    private Long id;
    private String title;
    private String content;
    private String type;
    private String priority;
    private Long senderId;
    private Long receiverId;
    private String status;
    
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private LocalDateTime readTime;
    
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
    private LocalDateTime createdTime;
    
    // getters and setters...
}
```

### 4.3 内部服务类

```java
package com.xiaou.common.service;

import org.springframework.stereotype.Service;
import org.springframework.scheduling.annotation.Async;

@Service
public class NotificationService {
    
    @Autowired
    private NotificationMapper notificationMapper;
    
    /**
     * 同步发送单个消息
     */
    public boolean sendNotification(Notification notification) {
        try {
            notificationMapper.insert(notification);
            return true;
        } catch (Exception e) {
            log.error("发送消息失败", e);
            return false;
        }
    }
    
    /**
     * 异步发送消息
     */
    @Async
    public void sendNotificationAsync(Notification notification) {
        sendNotification(notification);
    }
    
    /**
     * 批量发送消息
     */
    @Async
    public void sendBatchNotifications(List<Notification> notifications) {
        try {
            notificationMapper.batchInsert(notifications);
        } catch (Exception e) {
            log.error("批量发送消息失败", e);
        }
    }
    
    /**
     * 获取未读消息数量
     */
    public int getUnreadCount(Long userId) {
        return notificationMapper.countUnread(userId);
    }
}
```

### 4.4 MyBatis Mapper

```java
package com.xiaou.common.mapper;

import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface NotificationMapper {
    
    /**
     * 插入单个消息
     */
    int insert(Notification notification);
    
    /**
     * 批量插入消息
     */
    int batchInsert(@Param("list") List<Notification> notifications);
    
    /**
     * 统计未读消息数量
     */
    int countUnread(@Param("userId") Long userId);
    
    /**
     * 分页查询用户消息
     */
    List<Notification> selectByUserId(@Param("userId") Long userId, 
                                      @Param("offset") int offset, 
                                      @Param("limit") int limit);
    
    /**
     * 标记消息已读
     */
    int markAsRead(@Param("id") Long id, @Param("userId") Long userId);
    
    /**
     * 删除消息
     */
    int deleteMessage(@Param("id") Long id, @Param("userId") Long userId);
}
```

## 5. 前端接口设计

### 5.1 用户端接口

```java
@RestController
@RequestMapping("/api/notification")
public class NotificationController {
    
    /**
     * 获取消息列表
     */
    @PostMapping("/list")
    public Result<PageResponse<Notification>> getMessages(@RequestBody NotificationQueryRequest request) {
        // 实现逻辑
    }
    
    /**
     * 获取未读消息数量
     */
    @GetMapping("/unread-count")
    public Result<Integer> getUnreadCount() {
        Long userId = UserContextUtil.getCurrentUserId();
        int count = NotificationUtil.getUnreadCount(userId);
        return Result.success(count);
    }
    
    /**
     * 标记消息已读
     */
    @PostMapping("/mark-read")
    public Result<Void> markAsRead(@RequestBody MarkReadRequest request) {
        // 实现逻辑
    }
    
    /**
     * 删除消息
     */
    @PostMapping("/delete")
    public Result<Void> deleteMessage(@RequestBody DeleteMessageRequest request) {
        // 实现逻辑
    }
}
```

### 5.2 管理端接口

```java
@RestController
@RequestMapping("/api/admin/notification")
public class AdminNotificationController {
    
    /**
     * 发布系统公告
     */
    @PostMapping("/announcement")
    @RequireAdmin
    public Result<Void> publishAnnouncement(@RequestBody AnnouncementRequest request) {
        NotificationUtil.sendAnnouncement(request.getTitle(), request.getContent(), request.getPriority());
        return Result.success();
    }
    
    /**
     * 消息统计
     */
    @PostMapping("/statistics")
    @RequireAdmin
    public Result<NotificationStatistics> getStatistics(@RequestBody StatisticsRequest request) {
        // 实现逻辑
    }
}
```

## 6. 关键配置

### 6.1 异步配置

```java
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "notificationExecutor")
    public TaskExecutor notificationExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("notification-");
        executor.initialize();
        return executor;
    }
}
```

### 6.2 Redis配置（缓存未读数量）

```java
@Component
public class NotificationCacheUtil {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String UNREAD_COUNT_KEY = "notification:unread:";
    
    /**
     * 缓存未读数量
     */
    public void cacheUnreadCount(Long userId, int count) {
        redisTemplate.opsForValue().set(UNREAD_COUNT_KEY + userId, count, 30, TimeUnit.MINUTES);
    }
    
    /**
     * 获取缓存的未读数量
     */
    public Integer getCachedUnreadCount(Long userId) {
        Object count = redisTemplate.opsForValue().get(UNREAD_COUNT_KEY + userId);
        return count != null ? (Integer) count : null;
    }
    
    /**
     * 清除未读数量缓存
     */
    public void clearUnreadCountCache(Long userId) {
        redisTemplate.delete(UNREAD_COUNT_KEY + userId);
    }
}
```

## 7. 实施计划

### 阶段一：基础功能实现
1. **数据库表创建**：创建 notification 表
2. **工具类开发**：实现 NotificationUtil 核心方法
3. **基础接口**：用户端消息列表、详情接口
4. **简单测试**：验证消息发送和接收功能

### 阶段二：完善功能
1. **异步优化**：实现异步发送机制
2. **缓存集成**：Redis缓存未读数量
3. **管理端接口**：公告发布、消息统计
4. **前端页面**：基础的消息中心页面

### 阶段三：扩展优化
1. **模板系统**：支持消息模板
2. **性能优化**：批量处理、数据库优化
3. **监控告警**：消息发送失败监控
4. **完善前端**：丰富的消息管理界面

## 8. 部署和配置

### 8.1 SQL脚本执行
```sql
-- 执行数据库建表脚本
source notification.sql;

-- 初始化模板数据（可选）
INSERT INTO notification_template (code, name, title_template, content_template) VALUES
('WELCOME', '欢迎消息', '欢迎加入{platform}', '亲爱的{username}，欢迎加入我们的平台！'),
('COMMUNITY_LIKE', '帖子点赞', '您的帖子收到点赞', '您的帖子《{postTitle}》收到了{likerName}的点赞');
```

### 8.2 配置文件修改
```yaml
# application.yml 中添加异步配置
spring:
  task:
    execution:
      pool:
        core-size: 5
        max-size: 20
        queue-capacity: 100
```

## 9. 使用指南

### 9.1 基本使用
```java
// 最简单的使用方式
NotificationUtil.sendPersonalMessage(userId, "标题", "内容");

// 推荐使用异步方式
NotificationUtil.sendMessageAsync(userId, "标题", "内容");
```

