# 积分抽奖系统技术文档

## 一、业务背景

用户通过完成任务、签到、发帖等行为获得积分，可以消耗积分参与抽奖活动。

**核心挑战**：
1. **高并发**：多人同时抽奖，如何防止超发、重复抽奖
2. **概率精确**：如何实现精确的概率控制
3. **防刷**：如何防止恶意用户薅羊毛
4. **可扩展**：不同活动可能需要不同的抽奖策略

---

## 二、系统架构

### 2.1 整体流程

```
┌─────────────────────────────────────────────────────────────────┐
│                        抽奖请求流程                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │   用户发起抽奖   │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │  获取分布式锁    │ ← Redisson（防止同一用户并发抽奖）
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────────┐
              │        风控责任链检查         │
              │  ┌────────────────────────┐  │
              │  │ 1. 积分余额检查        │  │
              │  │ 2. 全局限流检查        │  │
              │  │ 3. IP限流检查          │  │
              │  │ 4. 用户限流检查        │  │
              │  │ 5. 冷却时间检查        │  │
              │  │ 6. 黑名单检查          │  │
              │  └────────────────────────┘  │
              └──────────────┬───────────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │    扣除积分      │
                    └────────┬────────┘
                             │
                             ▼
              ┌──────────────────────────────┐
              │        抽奖策略引擎          │
              │  ┌────────────────────────┐  │
              │  │ • Alias Method（标准）  │  │
              │  │ • 动态权重（递增概率）  │  │
              │  │ • 保底策略（N次必中）   │  │
              │  └────────────────────────┘  │
              └──────────────┬───────────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   扣减奖品库存   │ ← Redis 原子操作
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │                             │
              ▼                             ▼
        ┌──────────┐                 ┌──────────┐
        │ 扣减成功  │                 │ 扣减失败  │
        └────┬─────┘                 └────┬─────┘
             │                             │
             ▼                             ▼
        ┌──────────┐                 ┌──────────┐
        │ 发放奖励  │                 │ 回滚积分  │
        └────┬─────┘                 └──────────┘
             │
             ▼
        ┌──────────┐
        │ 记录日志  │
        └────┬─────┘
             │
             ▼
        ┌──────────┐
        │ 返回结果  │
        └──────────┘
```

### 2.2 技术选型

| 组件 | 技术 | 作用 |
|------|------|------|
| 分布式锁 | Redisson RLock | 防止用户并发抽奖 |
| 限流 | Redisson RRateLimiter | 三级限流保护 |
| 缓存 | Redis | 库存缓存、热点数据 |
| 设计模式 | 策略模式 | 多种抽奖算法可切换 |
| 设计模式 | 责任链模式 | 风控检查链 |
| 设计模式 | 工厂模式 | 策略实例化 |

---

## 三、Alias Method 别名采样算法

### 3.1 问题背景

假设有 4 个奖品，概率分别为：

| 奖品 | 概率 |
|------|------|
| 一等奖 | 1% |
| 二等奖 | 4% |
| 三等奖 | 15% |
| 谢谢参与 | 80% |

**传统轮盘赌做法**：

```java
double random = Math.random();  // 0.0 ~ 1.0
double cumulative = 0;

for (Prize prize : prizes) {
    cumulative += prize.probability;
    if (random <= cumulative) {
        return prize;  // 命中
    }
}
```

**问题**：时间复杂度 O(n)，奖品越多越慢

### 3.2 Alias Method 原理

**核心思想**：把不均匀的概率分布，转换成"选格子 + 抛硬币"的均匀操作

**预处理**：将概率分布转换为 n 个等高的柱子（每个柱子最多包含 2 种奖品）

```
原始概率：
┌───┐
│   │ 80%
│   │
│   │
│   │
├───┤
│   │ 15%
├───┤
│   │ 4%
├───┤ 1%
└───┘
 谢谢  三等  二等  一等

转换后（每列高度 = 25%）：
┌─────┬─────┬─────┬─────┐
│     │     │     │     │ 25%
│谢谢 │谢谢 │谢谢 │谢谢 │
│参与 │参与 │参与 │参与 │
├─────┼─────┼─────┼─────┤
│     │三等 │二等 │一等 │
│     │ 奖  │ 奖  │ 奖  │
└─────┴─────┴─────┴─────┘
  列0    列1   列2   列3

每列的 prob[i] 表示"选中本列奖品"的概率
每列的 alias[i] 表示"如果没选中本列，则选谁"
```

**抽奖**：
1. 随机选一列（均匀分布）
2. 抛硬币决定选本列奖品还是别名奖品

### 3.3 代码实现

```java
package com.xiaou.points.strategy.impl;

import java.util.*;

/**
 * Alias Method 别名采样算法
 * 时间复杂度：预处理 O(n)，抽奖 O(1)
 */
public class AliasMethodStrategy implements LotteryStrategy {
    
    private final Random random = new Random();
    
    @Override
    public LotteryPrizeConfig draw(Long userId, List<LotteryPrizeConfig> prizes) {
        // 1. 构建别名表
        AliasTable aliasTable = buildAliasTable(prizes);
        
        // 2. O(1) 抽奖
        return aliasTable.draw();
    }
    
    /**
     * 构建别名表
     */
    private AliasTable buildAliasTable(List<LotteryPrizeConfig> prizes) {
        int n = prizes.size();
        double[] prob = new double[n];   // 每列选中自己的概率
        int[] alias = new int[n];        // 每列的别名（如果没选中自己，选谁）
        
        // 1. 计算总概率
        double totalProbability = prizes.stream()
                .mapToDouble(p -> p.getCurrentProbability().doubleValue())
                .sum();
        
        // 2. 归一化：将概率转换为平均值为1的分布
        double[] normalizedProb = new double[n];
        for (int i = 0; i < n; i++) {
            normalizedProb[i] = prizes.get(i).getCurrentProbability().doubleValue() 
                    * n / totalProbability;
        }
        
        // 3. 分离"小于1"和"大于等于1"的概率
        List<Integer> small = new ArrayList<>();  // 概率 < 1 的索引
        List<Integer> large = new ArrayList<>();  // 概率 >= 1 的索引
        
        for (int i = 0; i < n; i++) {
            if (normalizedProb[i] < 1.0) {
                small.add(i);
            } else {
                large.add(i);
            }
        }
        
        // 4. 填充别名表
        while (!small.isEmpty() && !large.isEmpty()) {
            int less = small.remove(small.size() - 1);  // 取出一个"小的"
            int more = large.remove(large.size() - 1);  // 取出一个"大的"
            
            // 设置概率和别名
            prob[less] = normalizedProb[less];
            alias[less] = more;
            
            // 更新"大的"的概率（减去填给"小的"的部分）
            normalizedProb[more] = normalizedProb[more] + normalizedProb[less] - 1.0;
            
            // 重新分类
            if (normalizedProb[more] < 1.0) {
                small.add(more);
            } else {
                large.add(more);
            }
        }
        
        // 5. 处理剩余元素（浮点精度问题）
        while (!large.isEmpty()) {
            prob[large.remove(large.size() - 1)] = 1.0;
        }
        while (!small.isEmpty()) {
            prob[small.remove(small.size() - 1)] = 1.0;
        }
        
        return new AliasTable(prizes, prob, alias);
    }
    
    /**
     * 别名表
     */
    private class AliasTable {
        private final List<LotteryPrizeConfig> prizes;
        private final double[] prob;
        private final int[] alias;
        
        public AliasTable(List<LotteryPrizeConfig> prizes, double[] prob, int[] alias) {
            this.prizes = prizes;
            this.prob = prob;
            this.alias = alias;
        }
        
        /**
         * O(1) 抽奖
         */
        public LotteryPrizeConfig draw() {
            int n = prob.length;
            
            // 1. 随机选一列（均匀分布）
            int column = random.nextInt(n);
            
            // 2. 抛硬币：决定选本列还是别名列
            boolean coinFlip = random.nextDouble() < prob[column];
            
            // 3. 返回结果
            return prizes.get(coinFlip ? column : alias[column]);
        }
    }
}
```

### 3.4 时间复杂度对比

| 方法 | 预处理 | 单次抽奖 | 1000次抽奖（10种奖品） |
|------|--------|---------|----------------------|
| 轮盘赌 | O(1) | O(n) | 10000 次比较 |
| Alias Method | O(n) | **O(1)** | 2000 次操作 |

---

## 四、策略模式

### 4.1 类图

```
┌────────────────────────────┐
│    LotteryStrategy         │  ← 策略接口
│  (interface)               │
├────────────────────────────┤
│ + draw(userId, prizes)     │
│ + getStrategyName()        │
└────────────────────────────┘
              △
              │
    ┌─────────┼─────────┐
    │         │         │
┌───┴───┐ ┌───┴───┐ ┌───┴───┐
│Alias  │ │Dynamic│ │Guaran-│
│Method │ │Weight │ │tee    │  ← 具体策略
└───────┘ └───────┘ └───────┘
```

### 4.2 策略接口

```java
public interface LotteryStrategy {
    
    /**
     * 执行抽奖
     * @param userId 用户ID
     * @param prizes 奖品列表
     * @return 抽中的奖品
     */
    LotteryPrizeConfig draw(Long userId, List<LotteryPrizeConfig> prizes);
    
    /**
     * 获取策略名称
     */
    String getStrategyName();
}
```

### 4.3 动态权重策略

连续未中奖越多，中奖概率越高（提升用户体验）

```java
/**
 * 动态权重抽奖策略
 * 根据用户连续未中奖次数，动态提升中奖概率
 */
@Component
public class DynamicWeightStrategy implements LotteryStrategy {
    
    @Override
    public LotteryPrizeConfig draw(Long userId, List<LotteryPrizeConfig> prizes) {
        // 1. 获取用户连续未中奖次数
        int continuousNoWin = getContinuousNoWin(userId);
        
        // 2. 根据连续未中奖次数调整概率
        List<LotteryPrizeConfig> adjustedPrizes = adjustPrizes(prizes, continuousNoWin);
        
        // 3. 执行加权随机抽奖
        return weightedRandomDraw(adjustedPrizes);
    }
    
    /**
     * 调整奖品概率
     * 规则：每5次未中奖，中奖概率提升5%，最多提升50%
     */
    private List<LotteryPrizeConfig> adjustPrizes(
            List<LotteryPrizeConfig> prizes, int continuousNoWin) {
        
        if (continuousNoWin < 5) {
            return prizes;  // 未达到调整阈值
        }
        
        // 计算权重系数
        double weightFactor = 1.0 + (continuousNoWin - 5) * 0.05;
        weightFactor = Math.min(weightFactor, 1.5);  // 最多提升50%
        
        List<LotteryPrizeConfig> adjusted = new ArrayList<>();
        
        for (LotteryPrizeConfig prize : prizes) {
            LotteryPrizeConfig copy = copyPrize(prize);
            
            if (prize.getPrizeLevel() == 8) {
                // "未中奖"概率降低
                BigDecimal newProb = prize.getCurrentProbability()
                        .divide(BigDecimal.valueOf(weightFactor), 8, RoundingMode.HALF_UP);
                copy.setCurrentProbability(newProb);
            } else {
                // 其他奖品概率提升
                BigDecimal newProb = prize.getCurrentProbability()
                        .multiply(BigDecimal.valueOf(weightFactor));
                copy.setCurrentProbability(newProb);
            }
            
            adjusted.add(copy);
        }
        
        // 归一化概率
        normalizeProbabilities(adjusted);
        
        return adjusted;
    }
}
```

### 4.4 保底策略

连续 N 次未中奖，必中三等奖以上

```java
/**
 * 保底抽奖策略
 * 连续未中奖达到阈值后，必中三等奖以上
 */
@Component
public class GuaranteeStrategy implements LotteryStrategy {
    
    private static final int GUARANTEE_COUNT = 50;  // 50次必中
    
    @Override
    public LotteryPrizeConfig draw(Long userId, List<LotteryPrizeConfig> prizes) {
        int continuousNoWin = getContinuousNoWin(userId);
        
        // 判断是否触发保底
        if (continuousNoWin >= GUARANTEE_COUNT) {
            log.warn("用户{}连续{}次未中奖，触发保底机制", userId, continuousNoWin);
            return getGuaranteePrize(prizes);
        }
        
        // 未触发保底，使用普通抽奖
        return normalDraw(prizes);
    }
    
    /**
     * 保底奖品（三等奖以上）
     */
    private LotteryPrizeConfig getGuaranteePrize(List<LotteryPrizeConfig> prizes) {
        // 筛选出三等奖及以上的奖品（prizeLevel <= 4）
        List<LotteryPrizeConfig> highValuePrizes = prizes.stream()
                .filter(p -> p.getPrizeLevel() <= 4)
                .toList();
        
        // 在高价值奖品中随机选择一个
        return highValuePrizes.get(random.nextInt(highValuePrizes.size()));
    }
}
```

### 4.5 策略工厂

```java
@Component
public class LotteryStrategyFactory {
    
    private final Map<String, LotteryStrategy> strategyMap = new HashMap<>();
    
    @Autowired
    public LotteryStrategyFactory(List<LotteryStrategy> strategies) {
        for (LotteryStrategy strategy : strategies) {
            strategyMap.put(strategy.getStrategyName(), strategy);
        }
    }
    
    public LotteryStrategy getStrategy(String strategyType) {
        LotteryStrategy strategy = strategyMap.get(strategyType);
        if (strategy == null) {
            // 默认使用 Alias Method
            return strategyMap.get("ALIAS_METHOD");
        }
        return strategy;
    }
}
```

---

## 五、责任链模式（风控系统）

### 5.1 类图

```
┌────────────────────────────┐
│    RiskCheckHandler        │  ← 抽象处理器
│  (abstract)                │
├────────────────────────────┤
│ - next: RiskCheckHandler   │
│ + setNext(handler)         │
│ + check(userId, context)   │
│ # checkNext(userId, ctx)   │
└────────────────────────────┘
              △
              │
    ┌─────────┼─────────┬─────────┐
    │         │         │         │
┌───┴───┐ ┌───┴───┐ ┌───┴───┐ ┌───┴───┐
│Points │ │Rate   │ │Cool   │ │Black  │
│Check  │ │Limit  │ │down   │ │list   │
└───────┘ └───────┘ └───────┘ └───────┘
```

### 5.2 抽象处理器

```java
public abstract class RiskCheckHandler {
    
    protected RiskCheckHandler next;
    
    public void setNext(RiskCheckHandler next) {
        this.next = next;
    }
    
    /**
     * 检查方法（由子类实现）
     */
    public abstract boolean check(Long userId, LotteryContext context);
    
    /**
     * 调用下一个处理器
     */
    protected boolean checkNext(Long userId, LotteryContext context) {
        if (next != null) {
            return next.check(userId, context);
        }
        return true;  // 链结束，通过
    }
}
```

### 5.3 限流检查器（三级限流）

```java
@Component
public class RateLimitCheckHandler extends RiskCheckHandler {
    
    @Autowired
    private RedissonClient redissonClient;
    
    // 用户级限制：每分钟最多10次
    private static final String USER_RATE_LIMIT_KEY = "lottery:ratelimit:user:";
    private static final long USER_RATE = 10;
    private static final long USER_INTERVAL = 60;
    
    // IP级限制：每分钟最多50次
    private static final String IP_RATE_LIMIT_KEY = "lottery:ratelimit:ip:";
    private static final long IP_RATE = 50;
    private static final long IP_INTERVAL = 60;
    
    // 全局限制：每秒最多1000次
    private static final String GLOBAL_RATE_LIMIT_KEY = "lottery:ratelimit:global";
    private static final long GLOBAL_RATE = 1000;
    private static final long GLOBAL_INTERVAL = 1;
    
    @Override
    public boolean check(Long userId, LotteryContext context) {
        // 1. 检查全局限流
        if (!checkGlobalRateLimit()) {
            throw new BusinessException("系统繁忙，请稍后再试");
        }
        
        // 2. 检查用户级限流
        if (!checkUserRateLimit(userId)) {
            throw new BusinessException("操作过于频繁，请稍后再试");
        }
        
        // 3. 检查IP级限流
        if (context.getIp() != null && !checkIpRateLimit(context.getIp())) {
            throw new BusinessException("该IP操作过于频繁，请稍后再试");
        }
        
        return checkNext(userId, context);
    }
    
    /**
     * 检查全局限流
     */
    private boolean checkGlobalRateLimit() {
        RRateLimiter rateLimiter = redissonClient.getRateLimiter(GLOBAL_RATE_LIMIT_KEY);
        
        // 如果限流器未配置，则配置它
        if (!rateLimiter.isExists()) {
            rateLimiter.trySetRate(
                RateType.OVERALL, 
                GLOBAL_RATE, 
                GLOBAL_INTERVAL, 
                RateIntervalUnit.SECONDS
            );
        }
        
        // 尝试获取许可
        return rateLimiter.tryAcquire(1);
    }
    
    /**
     * 检查用户级限流
     */
    private boolean checkUserRateLimit(Long userId) {
        String key = USER_RATE_LIMIT_KEY + userId;
        RRateLimiter rateLimiter = redissonClient.getRateLimiter(key);
        
        if (!rateLimiter.isExists()) {
            rateLimiter.trySetRate(
                RateType.OVERALL, 
                USER_RATE, 
                USER_INTERVAL, 
                RateIntervalUnit.SECONDS
            );
        }
        
        return rateLimiter.tryAcquire(1);
    }
}
```

### 5.4 构建责任链

```java
@Component
public class RiskCheckChainBuilder {
    
    @Autowired
    private PointsCheckHandler pointsCheckHandler;
    
    @Autowired
    private RateLimitCheckHandler rateLimitCheckHandler;
    
    @Autowired
    private CooldownCheckHandler cooldownCheckHandler;
    
    @Autowired
    private BlacklistCheckHandler blacklistCheckHandler;
    
    /**
     * 构建风控检查链
     * 顺序：积分检查 → 限流检查 → 冷却检查 → 黑名单检查
     */
    public RiskCheckHandler buildChain() {
        pointsCheckHandler.setNext(rateLimitCheckHandler);
        rateLimitCheckHandler.setNext(cooldownCheckHandler);
        cooldownCheckHandler.setNext(blacklistCheckHandler);
        return pointsCheckHandler;
    }
}
```

---

## 六、分布式锁 + 库存回滚

### 6.1 为什么需要分布式锁？

**场景**：用户快速点击抽奖按钮，可能发起多个并发请求

**问题**：
- 同一用户并发扣积分，可能扣多次
- 库存同时被扣减，可能超发

**解决**：用户级分布式锁，保证同一用户同时只能有一个抽奖请求在处理

### 6.2 代码实现

```java
@Service
public class LotteryServiceImpl implements LotteryService {
    
    @Autowired
    private RedissonClient redissonClient;
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public LotteryDrawResponse draw(LotteryDrawRequest request, Long userId, 
                                    String ip, String device) {
        
        // 0. 检查熔断状态
        if (emergencyService.isCircuitBroken()) {
            throw new BusinessException("系统维护中，暂停抽奖服务");
        }
        
        // 1. 获取用户级分布式锁
        String lockKey = "lottery:lock:user:" + userId;
        RLock userLock = redissonClient.getLock(lockKey);
        
        LotteryPrizeConfig prize = null;
        boolean stockDeducted = false;
        
        try {
            // 尝试获取锁，等待3秒，持有10秒
            if (!userLock.tryLock(3, 10, TimeUnit.SECONDS)) {
                throw new BusinessException("操作过于频繁，请稍后再试");
            }
            
            // 2. 构建上下文
            LotteryContext context = buildContext(userId, request, ip, device);
            
            // 3. 执行风控检查链
            RiskCheckHandler checkChain = chainBuilder.buildChain();
            checkChain.check(userId, context);
            
            // 4. 扣除积分
            deductPoints(userId, DRAW_COST_POINTS);
            
            // 5. 执行抽奖
            prize = executeLottery(context);
            
            // 6. 扣减库存
            if (!stockService.deductStock(prize.getId())) {
                throw new BusinessException("奖品库存不足");
            }
            stockDeducted = true;
            
            // 7. 发放奖励
            issueReward(userId, prize);
            
            // 8. 更新用户限制
            updateUserLimit(userId, prize);
            
            // 9. 记录抽奖记录
            LotteryDrawRecord record = recordDraw(userId, prize, context);
            
            // 10. 发布事件（异步处理统计等）
            publishEvent(record);
            
            // 11. 构建响应
            return buildResponse(prize, record);
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            // 回滚库存
            if (stockDeducted && prize != null) {
                stockService.rollbackStock(prize.getId());
            }
            throw new BusinessException("系统繁忙，请稍后再试");
            
        } catch (Exception e) {
            // 回滚库存
            if (stockDeducted && prize != null) {
                stockService.rollbackStock(prize.getId());
            }
            throw new BusinessException("抽奖失败：" + e.getMessage());
            
        } finally {
            // 释放锁
            if (userLock.isHeldByCurrentThread()) {
                userLock.unlock();
            }
        }
    }
}
```

### 6.3 库存扣减（Redis 原子操作）

```java
@Service
public class LotteryStockService {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private static final String STOCK_KEY_PREFIX = "lottery:stock:";
    
    /**
     * 扣减库存（原子操作）
     * @return true=扣减成功，false=库存不足
     */
    public boolean deductStock(Long prizeId) {
        String key = STOCK_KEY_PREFIX + prizeId;
        
        // Lua 脚本保证原子性
        String script = 
            "local stock = redis.call('GET', KEYS[1]) " +
            "if stock and tonumber(stock) > 0 then " +
            "    redis.call('DECR', KEYS[1]) " +
            "    return 1 " +
            "else " +
            "    return 0 " +
            "end";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key)
        );
        
        return result != null && result == 1;
    }
    
    /**
     * 回滚库存
     */
    public void rollbackStock(Long prizeId) {
        String key = STOCK_KEY_PREFIX + prizeId;
        redisTemplate.opsForValue().increment(key);
    }
}
```

---

## 七、面试常见问题

### Q1：为什么用 Alias Method 而不是轮盘赌？

> 轮盘赌每次抽奖需要 O(n) 遍历，Alias Method 预处理后每次只需 O(1)。当奖品种类多或抽奖频繁时，性能差异明显。

### Q2：如何保证高并发下不超发？

> 三重保障：
> 1. **分布式锁**：同一用户同时只能有一个抽奖请求
> 2. **Redis 原子操作**：库存扣减使用 Lua 脚本保证原子性
> 3. **库存回滚**：异常时自动回滚库存

### Q3：责任链模式有什么好处？

> 1. **解耦**：每个检查器只关心自己的逻辑
> 2. **可扩展**：新增检查项只需添加处理器，不用改原有代码
> 3. **可配置**：可以动态调整检查顺序或跳过某些检查

### Q4：如何防止恶意刷奖？

> 多维度限流：
> - **全局限流**：保护系统不被打垮
> - **IP限流**：防止机器人批量刷
> - **用户限流**：限制单用户频率
> - **黑名单**：封禁异常用户

### Q5：保底机制会不会影响运营收益？

> 保底机制是一种用户体验优化，实际触发概率很低（连续50次不中奖）。而且保底奖品是三等奖，成本可控。长期来看，提升用户留存比短期收益更重要。

---

## 八、总结

本抽奖系统的核心技术点：

1. **Alias Method 算法**：O(1) 时间复杂度抽奖，高性能
2. **策略模式**：支持多种抽奖策略，运行时可切换
3. **责任链模式**：风控检查链，可扩展、可配置
4. **分布式锁**：Redisson 实现，防止并发问题
5. **三级限流**：全局/IP/用户，多维度防刷
6. **库存回滚**：异常时自动回滚，保证数据一致性

这套架构可以支撑中等规模的抽奖活动，QPS 600+ 稳定运行。
